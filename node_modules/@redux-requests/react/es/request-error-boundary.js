function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import React, { useState, useEffect, useContext } from 'react';
import PropTypes from 'prop-types';
import useQuery from './use-query';
import useMutation from './use-mutation';
import RequestsContext from './requests-context';

var InternalRequestErrorBoundary = /*#__PURE__*/function (_React$Component) {
  _inheritsLoose(InternalRequestErrorBoundary, _React$Component);

  function InternalRequestErrorBoundary(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    _this.state = {
      error: null
    };
    return _this;
  }

  InternalRequestErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {
    return {
      error: error
    };
  };

  var _proto = InternalRequestErrorBoundary.prototype;

  _proto.componentDidCatch = function componentDidCatch(error) {
    var _this$props = this.props,
        type = _this$props.type,
        requestKey = _this$props.requestKey,
        setActiveError = _this$props.setActiveError;

    if (type === error.type && requestKey === error.requestKey) {
      setActiveError(error);
    }
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        children = _this$props2.children,
        type = _this$props2.type,
        requestKey = _this$props2.requestKey,
        fallback = _this$props2.fallback;

    if (this.state.error && type === this.state.error.type && requestKey === this.state.error.requestKey) {
      return fallback(this.state.error);
    }

    return children;
  };

  return InternalRequestErrorBoundary;
}(React.Component);

var RequestErrorBoundary = function RequestErrorBoundary(_ref) {
  var type = _ref.type,
      requestKey = _ref.requestKey,
      autoReset = _ref.autoReset,
      children = _ref.children,
      fallback = _ref.fallback;
  var requestContext = useContext(RequestsContext);

  var _useState = useState(null),
      activeError = _useState[0],
      setActiveError = _useState[1];

  var _useState2 = useState(0),
      recoveryCounter = _useState2[0],
      setRecoveryCounter = _useState2[1];

  autoReset = autoReset === undefined ? requestContext.autoReset : autoReset;
  var query = useQuery({
    type: type,
    requestKey: requestKey,
    autoReset: autoReset,
    autoLoad: false,
    throwError: false,
    suspense: false,
    suspenseSsr: false
  });
  var mutation = useMutation({
    type: type,
    requestKey: requestKey,
    autoReset: autoReset,
    throwError: false,
    suspense: false
  });
  useEffect(function () {
    if (!query.error && !query.loading && !mutation.error && !mutation.loading && activeError) {
      setActiveError(null);
      setRecoveryCounter(function (v) {
        return v + 1;
      });
    }
  }, [query.error, query.loading, mutation.error, mutation.loading, activeError]);
  return /*#__PURE__*/React.createElement(InternalRequestErrorBoundary, {
    key: recoveryCounter,
    setActiveError: setActiveError,
    fallback: fallback,
    type: type,
    requestKey: requestKey
  }, children);
};

RequestErrorBoundary.propTypes = process.env.NODE_ENV !== "production" ? {
  type: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,
  requestKey: PropTypes.string,
  children: PropTypes.element.isRequired,
  fallback: PropTypes.func.isRequired,
  autoReset: PropTypes.bool
} : {};
export default RequestErrorBoundary;